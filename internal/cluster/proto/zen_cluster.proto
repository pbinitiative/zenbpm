syntax = "proto3";
package cluster;

import "zencommand.proto";

option go_package = "github.com/pbinitiative/zenbpm/internal/cluster/proto";

// GRPC API exposed through private GRPC endpoint
service ZenService {
  // Notify notifies this node that a remote node is ready
  // for bootstrapping.
  rpc Notify(NotifyRequest) returns (NotifyResponse);
  // Join joins a remote node to the cluster.
  rpc Join(JoinRequest) returns (JoinResponse);

  // requests directed at zen cluster leader to perform changes to ClusterState

  // called by a partition leader when new node joins the cluster
  rpc AddPartitionNode(AddPartitionNodeRequest)
      returns (AddPartitionNodeResponse);
  // called by a partition leader when node becomes unreachable
  rpc ShutdownPartitionNode(ShutdownPartitionNodeRequest)
      returns (ShutdownPartitionNodeResponse);
  // called by a partition leader when he becomes a leader of partition cluster
  rpc PartitionNodeLeaderChange(PartitionNodeLeaderChangeRequest)
      returns (PartitionNodeLeaderChangeResponse);
  // called by a partition leader when member node has to be reaped due to reap
  // settings
  rpc RemovePartitionNode(RemovePartitionNodeRequest)
      returns (RemovePartitionNodeResponse);
  // called by a partition leader when member node becomes responsive after
  // being marked as shut down
  rpc ResumePartitionNode(ResumePartitionNodeRequest)
      returns (ResumePartitionNodeResponse);

  // cluster management endpoints

  rpc ClusterBackup(ClusterBackupRequest) returns (ClusterBackupResponse);
  rpc ClusterRestore(ClusterRestoreRequest) returns (ClusterRestoreResponse);
  rpc ConfigurationUpdate(ConfigurationUpdateRequest)
      returns (ConfigurationUpdateResponse);
  rpc AssignPartition(AssignPartitionRequest) returns (AssignPartitionResponse);
  rpc UnassignPartition(UnassignPartitionRequest)
      returns (UnassignPartitionResponse);
  rpc PartitionBackup(PartitionBackupRequest) returns (PartitionBackupResponse);
  rpc PartitionRestore(PartitionRestoreRequest)
      returns (PartitionRestoreResponse);

  rpc NodeCommand(zencommand.Command) returns (NodeCommandResponse);

  // engine endpoints
  
  // Deploys definition into partitions that receiving node is leader of
  rpc DeployDefinition(DeployDefinitionRequest) returns (DeployDefinitionResponse);
  rpc ActivateJob(ActivateJobRequest) returns (stream ActivateJobResponse);
  rpc CompleteJob(CompleteJobRequest) returns (CompleteJobResponse);
  rpc PublishMessage(PublishMessageRequest) returns (PublishMessageResponse);
  rpc CreateInstance(CreateInstanceRequest) returns (CreateInstanceResponse);
  rpc GetProcessInstances(GetProcessInstancesRequest) returns (GetProcessInstancesResponse);
  rpc GetProcessInstance(GetProcessInstanceRequest) returns (GetProcessInstanceResponse);
  rpc GetProcessInstanceJobs(GetProcessInstanceJobsRequest) returns (GetProcessInstanceJobsResponse);
  rpc GetIncidents(GetIncidentsRequest) returns (GetIncidentsResponse);
  rpc ResolveIncident(ResolveIncidentRequest) returns (ResolveIncidentResponse);
}

// TODO: do we want to keep custom error struct or use the default error handling?
message ErrorResult {
  uint32 code = 1;
  string message = 2;
}

message NotifyRequest {
  string id = 1;
  string address = 2;
}

message NotifyResponse {
  optional ErrorResult error = 1;
}

message JoinRequest {
  string id = 1;
  string address = 2;
  bool voter = 3;
}

message JoinResponse {
  optional ErrorResult error = 1;
  string leader = 2;
}

message AddPartitionNodeRequest {
  string id = 1;
  string address = 2;
  bool voter = 3;
  uint32 partition = 4;
}

message AddPartitionNodeResponse {
  optional ErrorResult error = 1;
}

message ShutdownPartitionNodeRequest {
  string id = 1;
  uint32 partition = 2;
}

message ShutdownPartitionNodeResponse {
  optional ErrorResult error = 1;
}

message PartitionNodeLeaderChangeRequest {
  string id = 1;
  uint32 partition = 2;
}

message PartitionNodeLeaderChangeResponse {
  optional ErrorResult error = 1;
}

message RemovePartitionNodeRequest {
  string id = 1;
  uint32 partition = 2;
}

message RemovePartitionNodeResponse {
  optional ErrorResult error = 1;
}

message ResumePartitionNodeRequest {
  string id = 1;
  uint32 partition = 2;
}

message ResumePartitionNodeResponse {
  optional ErrorResult error = 1;
}

// INTERNAL ENGINE API START

message ProcessDefinition {
  int64 key = 1;
  int32 version = 2;
  string process_id = 3;
  bytes definition = 4;
}

message ProcessInstance {
  int64 key = 1;
  string process_id = 2;
  bytes variables = 3;
  int64 state = 4;
  int64 createdAt = 5;
  int64 definition_key = 6;
}

message Job {
  int64 key = 1;
  int64 element_instance_key = 2;
  string element_id = 3;
  int64 process_instance_key = 4;
  string type = 5;
  int64 state = 6;
  int64 created_at = 7;
  bytes variables = 8;
}

message Incident {
  int64 key = 1;
  int64 element_instance_key = 2;
  string element_id = 3;
  int64 process_instance_key = 4;
  string message = 5;
  int64 created_at = 6;
  optional int64 resolved_at = 7;
  int64 execution_token = 8;
}

message DeployDefinitionRequest {
  int64 key = 1;
  bytes data = 2;
}

message DeployDefinitionResponse {
  optional ErrorResult error = 1;
}

message CompleteJobRequest {
  int64 key = 1;
  bytes variables = 2; // []byte of json variables 
}

message CompleteJobResponse {
  optional ErrorResult error = 1;
}

message ActivateJobRequest {
  string job_type = 1;
}

message ActivateJobResponse {
  optional ErrorResult error = 1;
  InternalJob job = 2;
}

message InternalJob {
  int64 key = 1;
  int64 instance_key = 2;
  bytes variables = 3;
  string type = 4;
  int64 state = 5;
  string element_id = 6;
  int64 created_at = 7;
}

message PublishMessageRequest {
  string name = 1;
  int64 instance_key = 2;
  bytes variables = 3;
}

message PublishMessageResponse {
  optional ErrorResult error = 1;
}

message CreateInstanceRequest {
  oneof start_by{
    int64 definition_key = 1;
    string latest_process_id = 2;
  }
  bytes variables = 3;
}

message CreateInstanceResponse {
  optional ErrorResult error = 1;
  ProcessInstance process = 2;
}

message GetProcessInstancesRequest {
  int32 page = 1;
  int32 size = 2;
  repeated uint32 partitions = 3;
  int64 definition_key = 4;
}

message PartitionedProcessInstances {
  uint32 partition_id = 1;
  repeated ProcessInstance instances = 2;
}

message GetProcessInstancesResponse {
  optional ErrorResult error = 1;
  repeated PartitionedProcessInstances partitions = 2;
}

message GetProcessInstanceRequest {
  int64 process_instance_key = 1;
}

message GetProcessInstanceResponse {
  optional ErrorResult error = 1;
  ProcessInstance processes = 2;
}

message GetProcessInstanceJobsRequest {
  int64 process_instance_key = 1;
}

message GetProcessInstanceJobsResponse {
  optional ErrorResult error = 1;
  repeated Job jobs = 2;
}

message GetIncidentsRequest {
  int64 process_instance_key = 1;
}

message GetIncidentsResponse {
  optional ErrorResult error = 1;
  repeated Incident incidents = 2;
}

message ResolveIncidentRequest {
  int64 incident_key = 1;
}

message ResolveIncidentResponse {
  optional ErrorResult error = 1;
}
// INTERNAL ENGINE API END

// TODO: implement missing messages when needed by cluster communication
message PartitionRestoreRequest {}
message PartitionRestoreResponse {}
message PartitionBackupRequest {}
message PartitionBackupResponse {}
message UnassignPartitionRequest {}
message UnassignPartitionResponse {}
message AssignPartitionRequest {}
message AssignPartitionResponse {}
message ConfigurationUpdateRequest {}
message ConfigurationUpdateResponse {}
message ClusterRestoreRequest {}
message ClusterRestoreResponse {}
message ClusterBackupRequest {}
message ClusterBackupResponse {}

message NodeCommandResponse {
  optional ErrorResult error = 1;
  zencommand.Command.Type type = 2;
  oneof response {
    ClusterNodeChangeResponse node_change = 3;
    ClusterNodePartitionChangeResponse node_partition_change = 4;
  }
}

message ClusterNodeChangeResponse {}
message ClusterNodePartitionChangeResponse {}
