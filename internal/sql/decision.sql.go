// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: decision.sql

package sql

import (
	"context"
)

const findDecisionByIdAndDecisionDefinitionKey = `-- name: FindDecisionByIdAndDecisionDefinitionKey :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_definition_key = ?1
    and decision_id = ?2
`

type FindDecisionByIdAndDecisionDefinitionKeyParams struct {
	DecisionDefinitionKey int64  `json:"decision_definition_key"`
	DecisionID            string `json:"decision_id"`
}

func (q *Queries) FindDecisionByIdAndDecisionDefinitionKey(ctx context.Context, arg FindDecisionByIdAndDecisionDefinitionKeyParams) (Decision, error) {
	row := q.db.QueryRowContext(ctx, findDecisionByIdAndDecisionDefinitionKey, arg.DecisionDefinitionKey, arg.DecisionID)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const getDecisionsById = `-- name: GetDecisionsById :many
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_id = ?1
ORDER BY
    version desc
`

func (q *Queries) GetDecisionsById(ctx context.Context, decisionID string) ([]Decision, error) {
	rows, err := q.db.QueryContext(ctx, getDecisionsById, decisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Decision{}
	for rows.Next() {
		var i Decision
		if err := rows.Scan(
			&i.Version,
			&i.DecisionID,
			&i.VersionTag,
			&i.DecisionDefinitionID,
			&i.DecisionDefinitionKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDecisionById = `-- name: GetLatestDecisionById :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_id = ?1
ORDER BY
    version DESC
LIMIT 1
`

func (q *Queries) GetLatestDecisionById(ctx context.Context, decisionID string) (Decision, error) {
	row := q.db.QueryRowContext(ctx, getLatestDecisionById, decisionID)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const getLatestDecisionByIdAndDecisionDefinitionId = `-- name: GetLatestDecisionByIdAndDecisionDefinitionId :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision d
WHERE
    decision_id = ?1
    AND decision_definition_id = ?2
ORDER BY
    version DESC
LIMIT 1
`

type GetLatestDecisionByIdAndDecisionDefinitionIdParams struct {
	DecisionID           string `json:"decision_id"`
	DecisionDefinitionID string `json:"decision_definition_id"`
}

func (q *Queries) GetLatestDecisionByIdAndDecisionDefinitionId(ctx context.Context, arg GetLatestDecisionByIdAndDecisionDefinitionIdParams) (Decision, error) {
	row := q.db.QueryRowContext(ctx, getLatestDecisionByIdAndDecisionDefinitionId, arg.DecisionID, arg.DecisionDefinitionID)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const getLatestDecisionByIdAndVersionTag = `-- name: GetLatestDecisionByIdAndVersionTag :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_id = ?1
    AND version_tag = ?2
ORDER BY
    version DESC
LIMIT 1
`

type GetLatestDecisionByIdAndVersionTagParams struct {
	DecisionID string `json:"decision_id"`
	VersionTag string `json:"version_tag"`
}

func (q *Queries) GetLatestDecisionByIdAndVersionTag(ctx context.Context, arg GetLatestDecisionByIdAndVersionTagParams) (Decision, error) {
	row := q.db.QueryRowContext(ctx, getLatestDecisionByIdAndVersionTag, arg.DecisionID, arg.VersionTag)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const saveDecision = `-- name: SaveDecision :exec
INSERT INTO decision(version, decision_id, version_tag, decision_definition_id, decision_definition_key)
    VALUES (?, ?, ?, ?, ?)
`

type SaveDecisionParams struct {
	Version               int64  `json:"version"`
	DecisionID            string `json:"decision_id"`
	VersionTag            string `json:"version_tag"`
	DecisionDefinitionID  string `json:"decision_definition_id"`
	DecisionDefinitionKey int64  `json:"decision_definition_key"`
}

func (q *Queries) SaveDecision(ctx context.Context, arg SaveDecisionParams) error {
	_, err := q.db.ExecContext(ctx, saveDecision,
		arg.Version,
		arg.DecisionID,
		arg.VersionTag,
		arg.DecisionDefinitionID,
		arg.DecisionDefinitionKey,
	)
	return err
}
