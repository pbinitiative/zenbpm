// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: decision.sql

package sql

import (
	"context"
)

const findDecisionByIdAndDecisionDefinitionKey = `-- name: FindDecisionByIdAndDecisionDefinitionKey :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_definition_key = ?1
    and decision_id = ?2
`

type FindDecisionByIdAndDecisionDefinitionKeyParams struct {
	DecisionDefinitionKey int64  `json:"decision_definition_key"`
	DecisionID            string `json:"decision_id"`
}

func (q *Queries) FindDecisionByIdAndDecisionDefinitionKey(ctx context.Context, arg FindDecisionByIdAndDecisionDefinitionKeyParams) (Decision, error) {
	row := q.db.QueryRowContext(ctx, findDecisionByIdAndDecisionDefinitionKey, arg.DecisionDefinitionKey, arg.DecisionID)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const findDecisionsById = `-- name: FindDecisionsById :many
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_id = ?1
ORDER BY
    version desc
`

func (q *Queries) FindDecisionsById(ctx context.Context, decisionID string) ([]Decision, error) {
	rows, err := q.db.QueryContext(ctx, findDecisionsById, decisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Decision{}
	for rows.Next() {
		var i Decision
		if err := rows.Scan(
			&i.Version,
			&i.DecisionID,
			&i.VersionTag,
			&i.DecisionDefinitionID,
			&i.DecisionDefinitionKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestDecisionById = `-- name: FindLatestDecisionById :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_id = ?1
ORDER BY
    version DESC
LIMIT 1
`

func (q *Queries) FindLatestDecisionById(ctx context.Context, decisionID string) (Decision, error) {
	row := q.db.QueryRowContext(ctx, findLatestDecisionById, decisionID)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const findLatestDecisionByIdAndDecisionDefinitionId = `-- name: FindLatestDecisionByIdAndDecisionDefinitionId :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision d
WHERE
    decision_id = ?1
    AND decision_definition_id = ?2
ORDER BY
    version DESC
LIMIT 1
`

type FindLatestDecisionByIdAndDecisionDefinitionIdParams struct {
	DecisionID           string `json:"decision_id"`
	DecisionDefinitionID string `json:"decision_definition_id"`
}

func (q *Queries) FindLatestDecisionByIdAndDecisionDefinitionId(ctx context.Context, arg FindLatestDecisionByIdAndDecisionDefinitionIdParams) (Decision, error) {
	row := q.db.QueryRowContext(ctx, findLatestDecisionByIdAndDecisionDefinitionId, arg.DecisionID, arg.DecisionDefinitionID)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const findLatestDecisionByIdAndVersionTag = `-- name: FindLatestDecisionByIdAndVersionTag :one
SELECT
    version, decision_id, version_tag, decision_definition_id, decision_definition_key
FROM
    decision
WHERE
    decision_id = ?1
    AND version_tag = ?2
ORDER BY
    version DESC
LIMIT 1
`

type FindLatestDecisionByIdAndVersionTagParams struct {
	DecisionID string `json:"decision_id"`
	VersionTag string `json:"version_tag"`
}

func (q *Queries) FindLatestDecisionByIdAndVersionTag(ctx context.Context, arg FindLatestDecisionByIdAndVersionTagParams) (Decision, error) {
	row := q.db.QueryRowContext(ctx, findLatestDecisionByIdAndVersionTag, arg.DecisionID, arg.VersionTag)
	var i Decision
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DecisionDefinitionID,
		&i.DecisionDefinitionKey,
	)
	return i, err
}

const saveDecision = `-- name: SaveDecision :exec

INSERT INTO decision(version, decision_id, version_tag, decision_definition_id, decision_definition_key)
    VALUES (?, ?, ?, ?, ?)
`

type SaveDecisionParams struct {
	Version               int64  `json:"version"`
	DecisionID            string `json:"decision_id"`
	VersionTag            string `json:"version_tag"`
	DecisionDefinitionID  string `json:"decision_definition_id"`
	DecisionDefinitionKey int64  `json:"decision_definition_key"`
}

// Copyright 2021-present ZenBPM Contributors
// (based on git commit history).
//
// ZenBPM project is available under two licenses:
//   - SPDX-License-Identifier: AGPL-3.0-or-later (See LICENSE-AGPL.md)
//   - Enterprise License (See LICENSE-ENTERPRISE.md)
func (q *Queries) SaveDecision(ctx context.Context, arg SaveDecisionParams) error {
	_, err := q.db.ExecContext(ctx, saveDecision,
		arg.Version,
		arg.DecisionID,
		arg.VersionTag,
		arg.DecisionDefinitionID,
		arg.DecisionDefinitionKey,
	)
	return err
}
