// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: decision_definition.sql

package sql

import (
	"context"
)

const findDecisionDefinitionByIdAndDmnResourceDefinitionKey = `-- name: FindDecisionDefinitionByIdAndDmnResourceDefinitionKey :one
SELECT
    version, decision_id, version_tag, dmn_resource_definition_id, dmn_resource_definition_key
FROM
    decision_definition
WHERE
    dmn_resource_definition_key = ?1
    and decision_id = ?2
`

type FindDecisionDefinitionByIdAndDmnResourceDefinitionKeyParams struct {
	DmnResourceDefinitionKey int64  `json:"dmn_resource_definition_key"`
	DecisionID               string `json:"decision_id"`
}

func (q *Queries) FindDecisionDefinitionByIdAndDmnResourceDefinitionKey(ctx context.Context, arg FindDecisionDefinitionByIdAndDmnResourceDefinitionKeyParams) (DecisionDefinition, error) {
	row := q.db.QueryRowContext(ctx, findDecisionDefinitionByIdAndDmnResourceDefinitionKey, arg.DmnResourceDefinitionKey, arg.DecisionID)
	var i DecisionDefinition
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DmnResourceDefinitionID,
		&i.DmnResourceDefinitionKey,
	)
	return i, err
}

const findDecisionDefinitionsById = `-- name: FindDecisionDefinitionsById :many
SELECT
    version, decision_id, version_tag, dmn_resource_definition_id, dmn_resource_definition_key
FROM
    decision_definition
WHERE
    decision_id = ?1
ORDER BY
    version DESC
`

func (q *Queries) FindDecisionDefinitionsById(ctx context.Context, decisionID string) ([]DecisionDefinition, error) {
	rows, err := q.db.QueryContext(ctx, findDecisionDefinitionsById, decisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DecisionDefinition{}
	for rows.Next() {
		var i DecisionDefinition
		if err := rows.Scan(
			&i.Version,
			&i.DecisionID,
			&i.VersionTag,
			&i.DmnResourceDefinitionID,
			&i.DmnResourceDefinitionKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestDecisionDefinitionById = `-- name: FindLatestDecisionDefinitionById :one
SELECT
    version, decision_id, version_tag, dmn_resource_definition_id, dmn_resource_definition_key
FROM
    decision_definition
WHERE
    decision_id = ?1
ORDER BY
    version DESC
LIMIT 1
`

func (q *Queries) FindLatestDecisionDefinitionById(ctx context.Context, decisionID string) (DecisionDefinition, error) {
	row := q.db.QueryRowContext(ctx, findLatestDecisionDefinitionById, decisionID)
	var i DecisionDefinition
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DmnResourceDefinitionID,
		&i.DmnResourceDefinitionKey,
	)
	return i, err
}

const findLatestDecisionDefinitionByIdAndDecisionDefinitionId = `-- name: FindLatestDecisionDefinitionByIdAndDecisionDefinitionId :one
SELECT
    version, decision_id, version_tag, dmn_resource_definition_id, dmn_resource_definition_key
FROM
    decision_definition d
WHERE
    decision_id = ?1
    AND dmn_resource_definition_id = ?2
ORDER BY
    version DESC
LIMIT 1
`

type FindLatestDecisionDefinitionByIdAndDecisionDefinitionIdParams struct {
	DecisionID              string `json:"decision_id"`
	DmnResourceDefinitionID string `json:"dmn_resource_definition_id"`
}

func (q *Queries) FindLatestDecisionDefinitionByIdAndDecisionDefinitionId(ctx context.Context, arg FindLatestDecisionDefinitionByIdAndDecisionDefinitionIdParams) (DecisionDefinition, error) {
	row := q.db.QueryRowContext(ctx, findLatestDecisionDefinitionByIdAndDecisionDefinitionId, arg.DecisionID, arg.DmnResourceDefinitionID)
	var i DecisionDefinition
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DmnResourceDefinitionID,
		&i.DmnResourceDefinitionKey,
	)
	return i, err
}

const findLatestDecisionDefinitionByIdAndVersionTag = `-- name: FindLatestDecisionDefinitionByIdAndVersionTag :one
SELECT
    version, decision_id, version_tag, dmn_resource_definition_id, dmn_resource_definition_key
FROM
    decision_definition
WHERE
    decision_id = ?1
    AND version_tag = ?2
ORDER BY
    version DESC
LIMIT 1
`

type FindLatestDecisionDefinitionByIdAndVersionTagParams struct {
	DecisionID string `json:"decision_id"`
	VersionTag string `json:"version_tag"`
}

func (q *Queries) FindLatestDecisionDefinitionByIdAndVersionTag(ctx context.Context, arg FindLatestDecisionDefinitionByIdAndVersionTagParams) (DecisionDefinition, error) {
	row := q.db.QueryRowContext(ctx, findLatestDecisionDefinitionByIdAndVersionTag, arg.DecisionID, arg.VersionTag)
	var i DecisionDefinition
	err := row.Scan(
		&i.Version,
		&i.DecisionID,
		&i.VersionTag,
		&i.DmnResourceDefinitionID,
		&i.DmnResourceDefinitionKey,
	)
	return i, err
}

const saveDecisionDefinition = `-- name: SaveDecisionDefinition :exec
INSERT INTO decision_definition(version, decision_id, version_tag, dmn_resource_definition_id, dmn_resource_definition_key)
    VALUES (?, ?, ?, ?, ?)
`

type SaveDecisionDefinitionParams struct {
	Version                  int64  `json:"version"`
	DecisionID               string `json:"decision_id"`
	VersionTag               string `json:"version_tag"`
	DmnResourceDefinitionID  string `json:"dmn_resource_definition_id"`
	DmnResourceDefinitionKey int64  `json:"dmn_resource_definition_key"`
}

func (q *Queries) SaveDecisionDefinition(ctx context.Context, arg SaveDecisionDefinitionParams) error {
	_, err := q.db.ExecContext(ctx, saveDecisionDefinition,
		arg.Version,
		arg.DecisionID,
		arg.VersionTag,
		arg.DmnResourceDefinitionID,
		arg.DmnResourceDefinitionKey,
	)
	return err
}
