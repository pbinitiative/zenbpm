// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dmn_resource_definition.sql

package sql

import (
	"context"
)

const findAllDmnResourceDefinitions = `-- name: FindAllDmnResourceDefinitions :many
SELECT
    drd."key", drd.version, drd.dmn_resource_definition_id, drd.dmn_data, drd.dmn_checksum, drd.dmn_definition_name, COUNT(*) OVER () AS total_count
FROM
    dmn_resource_definition as drd
WHERE
    -- force sqlc to keep sort_by_order param by mentioning it in a where clause which is always true
    CASE WHEN ?1 IS NULL THEN 1 ELSE 1 END
    AND (
        CAST(?2 AS INTEGER) = 0
        OR drd.version = (
            SELECT MAX(drd2.version)
            FROM dmn_resource_definition AS drd2
            WHERE drd2.dmn_resource_definition_id = drd.dmn_resource_definition_id
        )
    )
    AND
    CASE WHEN ?3 IS NOT NULL THEN
         drd.dmn_resource_definition_id = ?3
    ELSE
        1
    END
    AND
    CASE WHEN ?4 IS NOT NULL THEN
         lower(drd.dmn_definition_name) like concat('%', lower(?4), '%')
    ELSE
        1
    END
ORDER BY
    -- workaround for sqlc which does not replace params in order by
    CASE CAST(?1 AS TEXT) WHEN 'dmnDefinitionName_asc' THEN drd.dmn_definition_name END ASC,
    CASE CAST(?1 AS TEXT) WHEN 'dmnDefinitionName_desc' THEN drd.dmn_definition_name END DESC,
    CASE CAST(?1 AS TEXT) WHEN 'dmnResourceDefinitionId_asc' THEN drd.dmn_resource_definition_id END ASC,
    CASE CAST(?1 AS TEXT) WHEN 'dmnResourceDefinitionId_desc' THEN drd.dmn_resource_definition_id END DESC,
    CASE CAST(?1 AS TEXT) WHEN 'version_asc' THEN drd.version END ASC,
    CASE CAST(?1 AS TEXT) WHEN 'version_desc' THEN drd.version END DESC,
    CASE CAST(?1 AS TEXT) WHEN 'key_asc' THEN drd.key END ASC,
    CASE CAST(?1 AS TEXT) WHEN 'key_desc' THEN drd.key END DESC,
    drd.dmn_resource_definition_id ASC, drd.version DESC

LIMIT ?6 OFFSET ?5
`

type FindAllDmnResourceDefinitionsParams struct {
	SortByOrder             interface{} `json:"sort_by_order"`
	OnlyLatest              int64       `json:"only_latest"`
	DmnResourceDefinitionID interface{} `json:"dmn_resource_definition_id"`
	DmnDefinitionName       interface{} `json:"dmn_definition_name"`
	Offset                  int64       `json:"offset"`
	Size                    int64       `json:"size"`
}

type FindAllDmnResourceDefinitionsRow struct {
	Key                     int64  `json:"key"`
	Version                 int64  `json:"version"`
	DmnResourceDefinitionID string `json:"dmn_resource_definition_id"`
	DmnData                 string `json:"dmn_data"`
	DmnChecksum             []byte `json:"dmn_checksum"`
	DmnDefinitionName       string `json:"dmn_definition_name"`
	TotalCount              int64  `json:"total_count"`
}

func (q *Queries) FindAllDmnResourceDefinitions(ctx context.Context, arg FindAllDmnResourceDefinitionsParams) ([]FindAllDmnResourceDefinitionsRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllDmnResourceDefinitions,
		arg.SortByOrder,
		arg.OnlyLatest,
		arg.DmnResourceDefinitionID,
		arg.DmnDefinitionName,
		arg.Offset,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllDmnResourceDefinitionsRow{}
	for rows.Next() {
		var i FindAllDmnResourceDefinitionsRow
		if err := rows.Scan(
			&i.Key,
			&i.Version,
			&i.DmnResourceDefinitionID,
			&i.DmnData,
			&i.DmnChecksum,
			&i.DmnDefinitionName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findDmnResourceDefinitionByKey = `-- name: FindDmnResourceDefinitionByKey :one
SELECT
    "key", version, dmn_resource_definition_id, dmn_data, dmn_checksum, dmn_definition_name
FROM
    dmn_resource_definition
WHERE
    key = ?1
`

func (q *Queries) FindDmnResourceDefinitionByKey(ctx context.Context, key int64) (DmnResourceDefinition, error) {
	row := q.db.QueryRowContext(ctx, findDmnResourceDefinitionByKey, key)
	var i DmnResourceDefinition
	err := row.Scan(
		&i.Key,
		&i.Version,
		&i.DmnResourceDefinitionID,
		&i.DmnData,
		&i.DmnChecksum,
		&i.DmnDefinitionName,
	)
	return i, err
}

const findDmnResourceDefinitionsById = `-- name: FindDmnResourceDefinitionsById :many
SELECT
    "key", version, dmn_resource_definition_id, dmn_data, dmn_checksum, dmn_definition_name
FROM
    dmn_resource_definition
WHERE
    dmn_resource_definition_id = ?1
ORDER BY
    version DESC
`

func (q *Queries) FindDmnResourceDefinitionsById(ctx context.Context, dmnResourceDefinitionID string) ([]DmnResourceDefinition, error) {
	rows, err := q.db.QueryContext(ctx, findDmnResourceDefinitionsById, dmnResourceDefinitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DmnResourceDefinition{}
	for rows.Next() {
		var i DmnResourceDefinition
		if err := rows.Scan(
			&i.Key,
			&i.Version,
			&i.DmnResourceDefinitionID,
			&i.DmnData,
			&i.DmnChecksum,
			&i.DmnDefinitionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestDmnResourceDefinitionById = `-- name: FindLatestDmnResourceDefinitionById :one
SELECT
    "key", version, dmn_resource_definition_id, dmn_data, dmn_checksum, dmn_definition_name
FROM
    dmn_resource_definition
WHERE
    dmn_resource_definition_id = ?1
ORDER BY
    version DESC
LIMIT 1
`

func (q *Queries) FindLatestDmnResourceDefinitionById(ctx context.Context, dmnResourceDefinitionID string) (DmnResourceDefinition, error) {
	row := q.db.QueryRowContext(ctx, findLatestDmnResourceDefinitionById, dmnResourceDefinitionID)
	var i DmnResourceDefinition
	err := row.Scan(
		&i.Key,
		&i.Version,
		&i.DmnResourceDefinitionID,
		&i.DmnData,
		&i.DmnChecksum,
		&i.DmnDefinitionName,
	)
	return i, err
}

const getDmnResourceDefinitionKeyByChecksum = `-- name: GetDmnResourceDefinitionKeyByChecksum :one
SELECT
    key
FROM
    dmn_resource_definition
WHERE
    dmn_checksum = ?1
LIMIT 1
`

func (q *Queries) GetDmnResourceDefinitionKeyByChecksum(ctx context.Context, dmnChecksum []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, getDmnResourceDefinitionKeyByChecksum, dmnChecksum)
	var key int64
	err := row.Scan(&key)
	return key, err
}

const saveDmnResourceDefinition = `-- name: SaveDmnResourceDefinition :exec
INSERT INTO dmn_resource_definition(key, version, dmn_resource_definition_id, dmn_data, dmn_checksum, dmn_definition_name)
    VALUES (?, ?, ?, ?, ?, ?)
`

type SaveDmnResourceDefinitionParams struct {
	Key                     int64  `json:"key"`
	Version                 int64  `json:"version"`
	DmnResourceDefinitionID string `json:"dmn_resource_definition_id"`
	DmnData                 string `json:"dmn_data"`
	DmnChecksum             []byte `json:"dmn_checksum"`
	DmnDefinitionName       string `json:"dmn_definition_name"`
}

func (q *Queries) SaveDmnResourceDefinition(ctx context.Context, arg SaveDmnResourceDefinitionParams) error {
	_, err := q.db.ExecContext(ctx, saveDmnResourceDefinition,
		arg.Key,
		arg.Version,
		arg.DmnResourceDefinitionID,
		arg.DmnData,
		arg.DmnChecksum,
		arg.DmnDefinitionName,
	)
	return err
}
