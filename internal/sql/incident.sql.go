// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: incident.sql

package sql

import (
	"context"
	"database/sql"
)

const findIncidentByKey = `-- name: FindIncidentByKey :one
SELECT
    "key", element_instance_key, element_id, process_instance_key, message, created_at, resolved_at, execution_token
FROM
    incident
WHERE
    key = ?1
`

func (q *Queries) FindIncidentByKey(ctx context.Context, key int64) (Incident, error) {
	row := q.db.QueryRowContext(ctx, findIncidentByKey, key)
	var i Incident
	err := row.Scan(
		&i.Key,
		&i.ElementInstanceKey,
		&i.ElementID,
		&i.ProcessInstanceKey,
		&i.Message,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ExecutionToken,
	)
	return i, err
}

const findIncidents = `-- name: FindIncidents :many
SELECT
    "key", element_instance_key, element_id, process_instance_key, message, created_at, resolved_at, execution_token
FROM
    incident
WHERE
    COALESCE(?1, process_instance_key) = process_instance_key
    AND COALESCE(?2, "element_instance_key") = "element_instance_key"
`

type FindIncidentsParams struct {
	ProcessInstanceKey sql.NullInt64 `json:"process_instance_key"`
	ElementInstanceKey sql.NullInt64 `json:"element_instance_key"`
}

func (q *Queries) FindIncidents(ctx context.Context, arg FindIncidentsParams) ([]Incident, error) {
	rows, err := q.db.QueryContext(ctx, findIncidents, arg.ProcessInstanceKey, arg.ElementInstanceKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Incident{}
	for rows.Next() {
		var i Incident
		if err := rows.Scan(
			&i.Key,
			&i.ElementInstanceKey,
			&i.ElementID,
			&i.ProcessInstanceKey,
			&i.Message,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ExecutionToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findIncidentsByProcessInstanceKey = `-- name: FindIncidentsByProcessInstanceKey :many
SELECT
    "key", element_instance_key, element_id, process_instance_key, message, created_at, resolved_at, execution_token
FROM
    incident
WHERE
    process_instance_key = ?1
`

func (q *Queries) FindIncidentsByProcessInstanceKey(ctx context.Context, processInstanceKey int64) ([]Incident, error) {
	rows, err := q.db.QueryContext(ctx, findIncidentsByProcessInstanceKey, processInstanceKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Incident{}
	for rows.Next() {
		var i Incident
		if err := rows.Scan(
			&i.Key,
			&i.ElementInstanceKey,
			&i.ElementID,
			&i.ProcessInstanceKey,
			&i.Message,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ExecutionToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveIncident = `-- name: SaveIncident :exec

INSERT INTO incident(key, element_id, element_instance_key, process_instance_key, message, created_at, resolved_at, execution_token)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT
    DO UPDATE SET
        resolved_at = excluded.resolved_at
`

type SaveIncidentParams struct {
	Key                int64         `json:"key"`
	ElementID          string        `json:"element_id"`
	ElementInstanceKey int64         `json:"element_instance_key"`
	ProcessInstanceKey int64         `json:"process_instance_key"`
	Message            string        `json:"message"`
	CreatedAt          int64         `json:"created_at"`
	ResolvedAt         sql.NullInt64 `json:"resolved_at"`
	ExecutionToken     int64         `json:"execution_token"`
}

// Copyright 2021-present ZenBPM Contributors
// (based on git commit history).
//
// ZenBPM project is available under two licenses:
//   - SPDX-License-Identifier: AGPL-3.0-or-later (See LICENSE-AGPL.md)
//   - Enterprise License (See LICENSE-ENTERPRISE.md)
func (q *Queries) SaveIncident(ctx context.Context, arg SaveIncidentParams) error {
	_, err := q.db.ExecContext(ctx, saveIncident,
		arg.Key,
		arg.ElementID,
		arg.ElementInstanceKey,
		arg.ProcessInstanceKey,
		arg.Message,
		arg.CreatedAt,
		arg.ResolvedAt,
		arg.ExecutionToken,
	)
	return err
}
