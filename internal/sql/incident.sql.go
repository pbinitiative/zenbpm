// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: incident.sql

package sql

import (
	"context"
	"database/sql"
	"strings"
)

const deleteProcessInstancesIncidents = `-- name: DeleteProcessInstancesIncidents :exec
DELETE FROM incident
WHERE process_instance_key IN (/*SLICE:keys*/?)
`

func (q *Queries) DeleteProcessInstancesIncidents(ctx context.Context, keys []int64) error {
	query := deleteProcessInstancesIncidents
	var queryParams []interface{}
	if len(keys) > 0 {
		for _, v := range keys {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:keys*/?", strings.Repeat(",?", len(keys))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:keys*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const findIncidentByKey = `-- name: FindIncidentByKey :one
SELECT
    "key", element_instance_key, element_id, process_instance_key, message, created_at, resolved_at, execution_token
FROM
    incident
WHERE
    key = ?1
`

func (q *Queries) FindIncidentByKey(ctx context.Context, key int64) (Incident, error) {
	row := q.db.QueryRowContext(ctx, findIncidentByKey, key)
	var i Incident
	err := row.Scan(
		&i.Key,
		&i.ElementInstanceKey,
		&i.ElementID,
		&i.ProcessInstanceKey,
		&i.Message,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ExecutionToken,
	)
	return i, err
}

const findIncidents = `-- name: FindIncidents :many
SELECT
    "key", element_instance_key, element_id, process_instance_key, message, created_at, resolved_at, execution_token
FROM
    incident
WHERE
    COALESCE(?1, process_instance_key) = process_instance_key
    AND COALESCE(?2, "element_instance_key") = "element_instance_key"
`

type FindIncidentsParams struct {
	ProcessInstanceKey sql.NullInt64 `json:"process_instance_key"`
	ElementInstanceKey sql.NullInt64 `json:"element_instance_key"`
}

func (q *Queries) FindIncidents(ctx context.Context, arg FindIncidentsParams) ([]Incident, error) {
	rows, err := q.db.QueryContext(ctx, findIncidents, arg.ProcessInstanceKey, arg.ElementInstanceKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Incident{}
	for rows.Next() {
		var i Incident
		if err := rows.Scan(
			&i.Key,
			&i.ElementInstanceKey,
			&i.ElementID,
			&i.ProcessInstanceKey,
			&i.Message,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ExecutionToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findIncidentsByProcessInstanceKey = `-- name: FindIncidentsByProcessInstanceKey :many
SELECT
    "key", element_instance_key, element_id, process_instance_key, message, created_at, resolved_at, execution_token
FROM
    incident
WHERE
    process_instance_key = ?1
`

func (q *Queries) FindIncidentsByProcessInstanceKey(ctx context.Context, processInstanceKey int64) ([]Incident, error) {
	rows, err := q.db.QueryContext(ctx, findIncidentsByProcessInstanceKey, processInstanceKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Incident{}
	for rows.Next() {
		var i Incident
		if err := rows.Scan(
			&i.Key,
			&i.ElementInstanceKey,
			&i.ElementID,
			&i.ProcessInstanceKey,
			&i.Message,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ExecutionToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveIncident = `-- name: SaveIncident :exec
INSERT INTO incident(key, element_id, element_instance_key, process_instance_key, message, created_at, resolved_at, execution_token)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT
    DO UPDATE SET
        resolved_at = excluded.resolved_at
`

type SaveIncidentParams struct {
	Key                int64         `json:"key"`
	ElementID          string        `json:"element_id"`
	ElementInstanceKey int64         `json:"element_instance_key"`
	ProcessInstanceKey int64         `json:"process_instance_key"`
	Message            string        `json:"message"`
	CreatedAt          int64         `json:"created_at"`
	ResolvedAt         sql.NullInt64 `json:"resolved_at"`
	ExecutionToken     int64         `json:"execution_token"`
}

func (q *Queries) SaveIncident(ctx context.Context, arg SaveIncidentParams) error {
	_, err := q.db.ExecContext(ctx, saveIncident,
		arg.Key,
		arg.ElementID,
		arg.ElementInstanceKey,
		arg.ProcessInstanceKey,
		arg.Message,
		arg.CreatedAt,
		arg.ResolvedAt,
		arg.ExecutionToken,
	)
	return err
}
