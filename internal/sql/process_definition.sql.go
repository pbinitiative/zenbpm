// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: process_definition.sql

package sql

import (
	"context"
	"database/sql"
	"strings"
)

const findAllProcessDefinitions = `-- name: FindAllProcessDefinitions :many
SELECT
    "key", version, bpmn_process_id, bpmn_data, bpmn_checksum, bpmn_process_name
FROM
    process_definition
ORDER BY
    version DESC
`

func (q *Queries) FindAllProcessDefinitions(ctx context.Context) ([]ProcessDefinition, error) {
	rows, err := q.db.QueryContext(ctx, findAllProcessDefinitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessDefinition{}
	for rows.Next() {
		var i ProcessDefinition
		if err := rows.Scan(
			&i.Key,
			&i.Version,
			&i.BpmnProcessID,
			&i.BpmnData,
			&i.BpmnChecksum,
			&i.BpmnProcessName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestProcessDefinitionById = `-- name: FindLatestProcessDefinitionById :one
SELECT
    "key", version, bpmn_process_id, bpmn_data, bpmn_checksum, bpmn_process_name
FROM
    process_definition
WHERE
    bpmn_process_id = ?1
ORDER BY
    version DESC
LIMIT 1
`

func (q *Queries) FindLatestProcessDefinitionById(ctx context.Context, bpmnProcessID string) (ProcessDefinition, error) {
	row := q.db.QueryRowContext(ctx, findLatestProcessDefinitionById, bpmnProcessID)
	var i ProcessDefinition
	err := row.Scan(
		&i.Key,
		&i.Version,
		&i.BpmnProcessID,
		&i.BpmnData,
		&i.BpmnChecksum,
		&i.BpmnProcessName,
	)
	return i, err
}

const findProcessDefinitionByKey = `-- name: FindProcessDefinitionByKey :one
SELECT
    "key", version, bpmn_process_id, bpmn_data, bpmn_checksum, bpmn_process_name
FROM
    process_definition
WHERE
    key = ?1
`

func (q *Queries) FindProcessDefinitionByKey(ctx context.Context, key int64) (ProcessDefinition, error) {
	row := q.db.QueryRowContext(ctx, findProcessDefinitionByKey, key)
	var i ProcessDefinition
	err := row.Scan(
		&i.Key,
		&i.Version,
		&i.BpmnProcessID,
		&i.BpmnData,
		&i.BpmnChecksum,
		&i.BpmnProcessName,
	)
	return i, err
}

const findProcessDefinitionStatistics = `-- name: FindProcessDefinitionStatistics :many
WITH filtered_definitions AS (
  SELECT
    pd."key",
    pd.version,
    pd.bpmn_process_id,
    pd.bpmn_process_name
  FROM process_definition AS pd
  WHERE
    -- force sqlc to keep sort param
    CAST(?3 AS TEXT) IS CAST(?3 AS TEXT)
    -- name filter (partial match)
    AND (CAST(?4 AS TEXT) IS NULL OR pd.bpmn_process_name LIKE '%' || CAST(?4 AS TEXT) || '%')
    -- onlyLatest filter
    AND (
      CAST(?5 AS INTEGER) = 0
      OR pd.version = (
        SELECT MAX(pd2.version)
        FROM process_definition AS pd2
        WHERE pd2.bpmn_process_id = pd.bpmn_process_id
      )
    )
    -- force sqlc to register both boolean flags before slices to maintain positional parameter order
    AND CAST(?6 AS INTEGER) IS CAST(?6 AS INTEGER)
    AND CAST(?7 AS INTEGER) IS CAST(?7 AS INTEGER)
    -- bpmnProcessId IN filter (boolean flag + slice, each slice appears only once)
    AND (CAST(?6 AS INTEGER) = 0 OR pd.bpmn_process_id IN (/*SLICE:bpmn_process_id_in*/?))
    -- definitionKey IN filter (boolean flag + slice, each slice appears only once)
    AND (CAST(?7 AS INTEGER) = 0 OR pd."key" IN (/*SLICE:definition_key_in*/?))
),
instance_counts AS (
  SELECT
    pi.process_definition_key,
    COUNT(*) AS total_instances,
    SUM(CASE WHEN pi.state = 1 THEN 1 ELSE 0 END) AS active_count,
    SUM(CASE WHEN pi.state = 4 THEN 1 ELSE 0 END) AS completed_count,
    SUM(CASE WHEN pi.state = 9 THEN 1 ELSE 0 END) AS terminated_count,
    SUM(CASE WHEN pi.state = 6 THEN 1 ELSE 0 END) AS failed_count
  FROM process_instance AS pi
  WHERE pi.process_definition_key IN (SELECT "key" FROM filtered_definitions)
  GROUP BY pi.process_definition_key
)
SELECT
  fd."key",
  fd.version,
  fd.bpmn_process_id,
  fd.bpmn_process_name,
  COALESCE(ic.total_instances, 0) AS total_instances,
  COALESCE(ic.active_count, 0) AS active_count,
  COALESCE(ic.completed_count, 0) AS completed_count,
  COALESCE(ic.terminated_count, 0) AS terminated_count,
  COALESCE(ic.failed_count, 0) AS failed_count,
  COUNT(*) OVER() AS total_count
FROM filtered_definitions AS fd
LEFT JOIN instance_counts AS ic ON fd."key" = ic.process_definition_key
ORDER BY
  -- workaround for sqlc - sort parameter handling
  CASE CAST(?3 AS TEXT) WHEN 'name_asc' THEN fd.bpmn_process_name END ASC,
  CASE CAST(?3 AS TEXT) WHEN 'name_desc' THEN fd.bpmn_process_name END DESC,
  CASE CAST(?3 AS TEXT) WHEN 'bpmnProcessId_asc' THEN fd.bpmn_process_id END ASC,
  CASE CAST(?3 AS TEXT) WHEN 'bpmnProcessId_desc' THEN fd.bpmn_process_id END DESC,
  CASE CAST(?3 AS TEXT) WHEN 'version_asc' THEN fd.version END ASC,
  CASE CAST(?3 AS TEXT) WHEN 'version_desc' THEN fd.version END DESC,
  CASE CAST(?3 AS TEXT) WHEN 'instanceCount_asc' THEN COALESCE(ic.total_instances, 0) END ASC,
  CASE CAST(?3 AS TEXT) WHEN 'instanceCount_desc' THEN COALESCE(ic.total_instances, 0) END DESC,
  fd."key" DESC
LIMIT ?2
OFFSET ?1
`

type FindProcessDefinitionStatisticsParams struct {
	Offset             int64          `json:"offset"`
	Limit              int64          `json:"limit"`
	Sort               sql.NullString `json:"sort"`
	NameFilter         sql.NullString `json:"name_filter"`
	OnlyLatest         int64          `json:"only_latest"`
	UseBpmnProcessIDIn int64          `json:"use_bpmn_process_id_in"`
	UseDefinitionKeyIn int64          `json:"use_definition_key_in"`
	BpmnProcessIDIn    []string       `json:"bpmn_process_id_in"`
	DefinitionKeyIn    []int64        `json:"definition_key_in"`
}

type FindProcessDefinitionStatisticsRow struct {
	Key             int64   `json:"key"`
	Version         int64   `json:"version"`
	BpmnProcessID   string  `json:"bpmn_process_id"`
	BpmnProcessName string  `json:"bpmn_process_name"`
	TotalInstances  int64   `json:"total_instances"`
	ActiveCount     float64 `json:"active_count"`
	CompletedCount  float64 `json:"completed_count"`
	TerminatedCount float64 `json:"terminated_count"`
	FailedCount     float64 `json:"failed_count"`
	TotalCount      int64   `json:"total_count"`
}

func (q *Queries) FindProcessDefinitionStatistics(ctx context.Context, arg FindProcessDefinitionStatisticsParams) ([]FindProcessDefinitionStatisticsRow, error) {
	query := findProcessDefinitionStatistics
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Offset)
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Sort)
	queryParams = append(queryParams, arg.NameFilter)
	queryParams = append(queryParams, arg.OnlyLatest)
	queryParams = append(queryParams, arg.UseBpmnProcessIDIn)
	queryParams = append(queryParams, arg.UseDefinitionKeyIn)
	if len(arg.BpmnProcessIDIn) > 0 {
		for _, v := range arg.BpmnProcessIDIn {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:bpmn_process_id_in*/?", strings.Repeat(",?", len(arg.BpmnProcessIDIn))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:bpmn_process_id_in*/?", "NULL", 1)
	}
	if len(arg.DefinitionKeyIn) > 0 {
		for _, v := range arg.DefinitionKeyIn {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:definition_key_in*/?", strings.Repeat(",?", len(arg.DefinitionKeyIn))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:definition_key_in*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindProcessDefinitionStatisticsRow{}
	for rows.Next() {
		var i FindProcessDefinitionStatisticsRow
		if err := rows.Scan(
			&i.Key,
			&i.Version,
			&i.BpmnProcessID,
			&i.BpmnProcessName,
			&i.TotalInstances,
			&i.ActiveCount,
			&i.CompletedCount,
			&i.TerminatedCount,
			&i.FailedCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProcessDefinitions = `-- name: FindProcessDefinitions :many
SELECT
  pd."key",
  pd.version,
  pd.bpmn_process_id,
  pd.bpmn_process_name,
  COUNT(*) OVER() AS total_count
FROM process_definition AS pd
WHERE
  CAST(?1 AS TEXT) IS CAST(?1 AS TEXT)
  AND (CAST(?2 AS TEXT) IS NULL OR pd.bpmn_process_id = CAST(?2 AS TEXT))
  AND (
    CAST(?3 AS INTEGER) = 0
    OR pd.version = (
      SELECT MAX(pd2.version)
      FROM process_definition AS pd2
      WHERE pd2.bpmn_process_id = pd.bpmn_process_id
        AND (CAST(?2 AS TEXT) IS NULL OR pd2.bpmn_process_id = CAST(?2 AS TEXT))
    )
  )
  
ORDER BY
  CASE CAST(?1 AS TEXT) WHEN 'version_asc'  THEN pd.version END ASC,
  CASE CAST(?1 AS TEXT) WHEN 'version_desc' THEN pd.version END DESC,
  CASE CAST(?1 AS TEXT) WHEN 'key_asc' THEN pd."key" END ASC,
  CASE CAST(?1 AS TEXT) WHEN 'key_desc' THEN pd."key" END DESC,
  CASE CAST(?1 AS TEXT) WHEN 'bpmnProcessId_asc' THEN pd.bpmn_process_id END ASC,
  CASE CAST(?1 AS TEXT) WHEN 'bpmnProcessId_desc' THEN pd.bpmn_process_id END DESC,
  CASE CAST(?1 AS TEXT) WHEN 'bpmnProcessName_asc' THEN pd.bpmn_process_name END ASC,
  CASE CAST(?1 AS TEXT) WHEN 'bpmnProcessName_desc' THEN pd.bpmn_process_name END DESC,
  pd."key" DESC

LIMIT ?5
OFFSET ?4
`

type FindProcessDefinitionsParams struct {
	Sort                sql.NullString `json:"sort"`
	BpmnProcessIDFilter sql.NullString `json:"bpmn_process_id_filter"`
	OnlyLatest          int64          `json:"only_latest"`
	Offset              int64          `json:"offset"`
	Limit               int64          `json:"limit"`
}

type FindProcessDefinitionsRow struct {
	Key             int64  `json:"key"`
	Version         int64  `json:"version"`
	BpmnProcessID   string `json:"bpmn_process_id"`
	BpmnProcessName string `json:"bpmn_process_name"`
	TotalCount      int64  `json:"total_count"`
}

// force sqlc to keep sort param
// workaround for sqlc does not replace params in order by
func (q *Queries) FindProcessDefinitions(ctx context.Context, arg FindProcessDefinitionsParams) ([]FindProcessDefinitionsRow, error) {
	rows, err := q.db.QueryContext(ctx, findProcessDefinitions,
		arg.Sort,
		arg.BpmnProcessIDFilter,
		arg.OnlyLatest,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindProcessDefinitionsRow{}
	for rows.Next() {
		var i FindProcessDefinitionsRow
		if err := rows.Scan(
			&i.Key,
			&i.Version,
			&i.BpmnProcessID,
			&i.BpmnProcessName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProcessDefinitionsById = `-- name: FindProcessDefinitionsById :many
SELECT
    "key", version, bpmn_process_id, bpmn_data, bpmn_checksum, bpmn_process_name
FROM
    process_definition
WHERE
    bpmn_process_id = ?1
ORDER BY
    version asc
`

func (q *Queries) FindProcessDefinitionsById(ctx context.Context, bpmnProcessIds string) ([]ProcessDefinition, error) {
	rows, err := q.db.QueryContext(ctx, findProcessDefinitionsById, bpmnProcessIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessDefinition{}
	for rows.Next() {
		var i ProcessDefinition
		if err := rows.Scan(
			&i.Key,
			&i.Version,
			&i.BpmnProcessID,
			&i.BpmnData,
			&i.BpmnChecksum,
			&i.BpmnProcessName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProcessDefinitionsByKeys = `-- name: FindProcessDefinitionsByKeys :many
SELECT
    "key", version, bpmn_process_id, bpmn_data, bpmn_checksum, bpmn_process_name
FROM
    process_definition
WHERE
    key IN (/*SLICE:keys*/?)
`

func (q *Queries) FindProcessDefinitionsByKeys(ctx context.Context, keys []int64) ([]ProcessDefinition, error) {
	query := findProcessDefinitionsByKeys
	var queryParams []interface{}
	if len(keys) > 0 {
		for _, v := range keys {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:keys*/?", strings.Repeat(",?", len(keys))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:keys*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessDefinition{}
	for rows.Next() {
		var i ProcessDefinition
		if err := rows.Scan(
			&i.Key,
			&i.Version,
			&i.BpmnProcessID,
			&i.BpmnData,
			&i.BpmnChecksum,
			&i.BpmnProcessName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefinitionKeyByChecksum = `-- name: GetDefinitionKeyByChecksum :one
SELECT
    key
FROM
    process_definition
WHERE
    bpmn_checksum = ?1
LIMIT 1
`

func (q *Queries) GetDefinitionKeyByChecksum(ctx context.Context, bpmnChecksum []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, getDefinitionKeyByChecksum, bpmnChecksum)
	var key int64
	err := row.Scan(&key)
	return key, err
}

const saveProcessDefinition = `-- name: SaveProcessDefinition :exec
INSERT INTO process_definition(key, version, bpmn_process_id, bpmn_data, bpmn_checksum,  bpmn_process_name)
    VALUES (?, ?, ?, ?, ?, ?)
`

type SaveProcessDefinitionParams struct {
	Key             int64  `json:"key"`
	Version         int64  `json:"version"`
	BpmnProcessID   string `json:"bpmn_process_id"`
	BpmnData        string `json:"bpmn_data"`
	BpmnChecksum    []byte `json:"bpmn_checksum"`
	BpmnProcessName string `json:"bpmn_process_name"`
}

func (q *Queries) SaveProcessDefinition(ctx context.Context, arg SaveProcessDefinitionParams) error {
	_, err := q.db.ExecContext(ctx, saveProcessDefinition,
		arg.Key,
		arg.Version,
		arg.BpmnProcessID,
		arg.BpmnData,
		arg.BpmnChecksum,
		arg.BpmnProcessName,
	)
	return err
}
