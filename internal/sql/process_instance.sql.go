// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: process_instance.sql

package sql

import (
	"context"
	"database/sql"
	"strings"
)

const countActiveProcessInstances = `-- name: CountActiveProcessInstances :one
SELECT
    count(*)
FROM
    process_instance
WHERE
    state = 1
`

func (q *Queries) CountActiveProcessInstances(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveProcessInstances)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProcessInstances = `-- name: DeleteProcessInstances :exec
DELETE FROM process_instance
WHERE key IN (/*SLICE:keys*/?)
`

func (q *Queries) DeleteProcessInstances(ctx context.Context, keys []int64) error {
	query := deleteProcessInstances
	var queryParams []interface{}
	if len(keys) > 0 {
		for _, v := range keys {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:keys*/?", strings.Repeat(",?", len(keys))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:keys*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const findActiveInstances = `-- name: FindActiveInstances :many
SELECT
    key
FROM
    process_instance
WHERE
    state IN (1, 8)
`

func (q *Queries) FindActiveInstances(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, findActiveInstances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var key int64
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findInactiveInstancesToDelete = `-- name: FindInactiveInstancesToDelete :many
SELECT
    pi.key
FROM
    process_instance AS pi
    LEFT JOIN execution_token AS et ON pi.parent_process_execution_token = et.key
    LEFT JOIN process_instance AS parent_pi ON et.process_instance_key = parent_pi.key
WHERE
    pi.state IN (4, 6, 9)
    AND (pi.parent_process_execution_token IS NULL
        OR parent_pi.state IN (4, 6, 9))
    AND (pi.history_delete_sec IS NULL
        OR pi.history_delete_sec < ?1)
`

func (q *Queries) FindInactiveInstancesToDelete(ctx context.Context, currunix sql.NullInt64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, findInactiveInstancesToDelete, currunix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var key int64
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProcessByParentExecutionToken = `-- name: FindProcessByParentExecutionToken :many
SELECT
    "key", process_definition_key, business_key, created_at, state, variables, parent_process_execution_token, history_ttl_sec, history_delete_sec
FROM
    process_instance
WHERE
    parent_process_execution_token = ?1
`

func (q *Queries) FindProcessByParentExecutionToken(ctx context.Context, parentProcessExecutionToken sql.NullInt64) ([]ProcessInstance, error) {
	rows, err := q.db.QueryContext(ctx, findProcessByParentExecutionToken, parentProcessExecutionToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessInstance{}
	for rows.Next() {
		var i ProcessInstance
		if err := rows.Scan(
			&i.Key,
			&i.ProcessDefinitionKey,
			&i.BusinessKey,
			&i.CreatedAt,
			&i.State,
			&i.Variables,
			&i.ParentProcessExecutionToken,
			&i.HistoryTtlSec,
			&i.HistoryDeleteSec,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProcessInstancesPage = `-- name: FindProcessInstancesPage :many
SELECT
    pi."key", pi.process_definition_key, pi.business_key, pi.created_at, pi.state, pi.variables, pi.parent_process_execution_token, pi.history_ttl_sec, pi.history_delete_sec, pd.bpmn_process_id,
    COUNT(*) OVER () AS total_count
FROM
    process_instance AS pi
    INNER JOIN process_definition AS pd ON pi.process_definition_key = pd.key
WHERE
    -- force sqlc to keep sort_by_order param by mentioning it in a where clause which is always true
    CASE WHEN ?1 IS NULL THEN 1 ELSE 1 END
    AND
    CASE WHEN ?2 <> 0 THEN
        pi.process_definition_key = ?2
    ELSE
        1
    END
    AND CASE WHEN ?3 <> 0 THEN
        pi.parent_process_execution_token IN (
            SELECT
                execution_token.key
            FROM
                execution_token
            WHERE
                execution_token.process_instance_key = ?3)
    ELSE
        1
    END
    AND
    CASE WHEN ?4 IS NOT NULL THEN
        pi.business_key = ?4
    ELSE
        1
    END
    AND
    CASE WHEN ?5 IS NOT NULL THEN
        pd.bpmn_process_id = ?5
    ELSE
        1
    END
    AND
    CASE WHEN ?6 IS NOT NULL THEN
       pi.created_at >= ?6
    ELSE
        1
    END
    AND
    CASE WHEN ?7 IS NOT NULL THEN
       pi.created_at <= ?7
    ELSE
        1
    END
    AND
    CASE WHEN ?8 IS NOT NULL THEN
       pi.state = ?8
    ELSE
        1
    END
ORDER BY
  CASE CAST(?1 AS TEXT) WHEN 'createdAt_asc'  THEN pi.created_at END ASC,
  CASE CAST(?1 AS TEXT) WHEN 'createdAt_desc' THEN pi.created_at END DESC,
  CASE CAST(?1 AS TEXT) WHEN 'key_asc' THEN pi."key" END ASC,
  CASE CAST(?1 AS TEXT) WHEN 'key_desc' THEN pi."key" END DESC,
  CASE CAST(?1 AS TEXT) WHEN 'state_asc' THEN pi.state END ASC,
  CASE CAST(?1 AS TEXT) WHEN 'state_desc' THEN pi.state END DESC,
  pi.created_at DESC

LIMIT ?10 OFFSET ?9
`

type FindProcessInstancesPageParams struct {
	SortByOrder          interface{} `json:"sort_by_order"`
	ProcessDefinitionKey interface{} `json:"process_definition_key"`
	ParentInstanceKey    interface{} `json:"parent_instance_key"`
	BusinessKey          interface{} `json:"business_key"`
	BpmnProcessID        interface{} `json:"bpmn_process_id"`
	CreatedFrom          interface{} `json:"created_from"`
	CreatedTo            interface{} `json:"created_to"`
	State                interface{} `json:"state"`
	Offset               int64       `json:"offset"`
	Size                 int64       `json:"size"`
}

type FindProcessInstancesPageRow struct {
	Key                         int64          `json:"key"`
	ProcessDefinitionKey        int64          `json:"process_definition_key"`
	BusinessKey                 sql.NullString `json:"business_key"`
	CreatedAt                   int64          `json:"created_at"`
	State                       int64          `json:"state"`
	Variables                   string         `json:"variables"`
	ParentProcessExecutionToken sql.NullInt64  `json:"parent_process_execution_token"`
	HistoryTtlSec               sql.NullInt64  `json:"history_ttl_sec"`
	HistoryDeleteSec            sql.NullInt64  `json:"history_delete_sec"`
	BpmnProcessID               string         `json:"bpmn_process_id"`
	TotalCount                  int64          `json:"total_count"`
}

// workaround for sqlc which does not replace params in order by
func (q *Queries) FindProcessInstancesPage(ctx context.Context, arg FindProcessInstancesPageParams) ([]FindProcessInstancesPageRow, error) {
	rows, err := q.db.QueryContext(ctx, findProcessInstancesPage,
		arg.SortByOrder,
		arg.ProcessDefinitionKey,
		arg.ParentInstanceKey,
		arg.BusinessKey,
		arg.BpmnProcessID,
		arg.CreatedFrom,
		arg.CreatedTo,
		arg.State,
		arg.Offset,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindProcessInstancesPageRow{}
	for rows.Next() {
		var i FindProcessInstancesPageRow
		if err := rows.Scan(
			&i.Key,
			&i.ProcessDefinitionKey,
			&i.BusinessKey,
			&i.CreatedAt,
			&i.State,
			&i.Variables,
			&i.ParentProcessExecutionToken,
			&i.HistoryTtlSec,
			&i.HistoryDeleteSec,
			&i.BpmnProcessID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessInstance = `-- name: GetProcessInstance :one
SELECT
    "key", process_definition_key, business_key, created_at, state, variables, parent_process_execution_token, history_ttl_sec, history_delete_sec
FROM
    process_instance
WHERE
    key = ?1
`

func (q *Queries) GetProcessInstance(ctx context.Context, key int64) (ProcessInstance, error) {
	row := q.db.QueryRowContext(ctx, getProcessInstance, key)
	var i ProcessInstance
	err := row.Scan(
		&i.Key,
		&i.ProcessDefinitionKey,
		&i.BusinessKey,
		&i.CreatedAt,
		&i.State,
		&i.Variables,
		&i.ParentProcessExecutionToken,
		&i.HistoryTtlSec,
		&i.HistoryDeleteSec,
	)
	return i, err
}

const saveProcessInstance = `-- name: SaveProcessInstance :exec
INSERT INTO process_instance(key, process_definition_key, created_at, state, variables, parent_process_execution_token, business_key)
    VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT (key)
    DO UPDATE SET
        state = excluded.state,
        variables = excluded.variables,
        business_key = excluded.business_key
`

type SaveProcessInstanceParams struct {
	Key                         int64          `json:"key"`
	ProcessDefinitionKey        int64          `json:"process_definition_key"`
	CreatedAt                   int64          `json:"created_at"`
	State                       int64          `json:"state"`
	Variables                   string         `json:"variables"`
	ParentProcessExecutionToken sql.NullInt64  `json:"parent_process_execution_token"`
	BusinessKey                 sql.NullString `json:"business_key"`
}

func (q *Queries) SaveProcessInstance(ctx context.Context, arg SaveProcessInstanceParams) error {
	_, err := q.db.ExecContext(ctx, saveProcessInstance,
		arg.Key,
		arg.ProcessDefinitionKey,
		arg.CreatedAt,
		arg.State,
		arg.Variables,
		arg.ParentProcessExecutionToken,
		arg.BusinessKey,
	)
	return err
}

const setProcessInstanceTTL = `-- name: SetProcessInstanceTTL :exec
UPDATE
    process_instance
SET
    history_ttl_sec = CASE WHEN CAST(?1 AS integer) IS NOT NULL THEN
        ?1
    ELSE
        history_ttl_sec
    END,
    history_delete_sec = CASE WHEN CAST(?2 AS integer) IS NOT NULL THEN
        ?2
    ELSE
        history_delete_sec
    END
WHERE
    key = ?3
`

type SetProcessInstanceTTLParams struct {
	HistoryTTLSec    sql.NullInt64 `json:"historyTTLSec"`
	HistoryDeleteSec sql.NullInt64 `json:"historyDeleteSec"`
	Key              int64         `json:"key"`
}

func (q *Queries) SetProcessInstanceTTL(ctx context.Context, arg SetProcessInstanceTTLParams) error {
	_, err := q.db.ExecContext(ctx, setProcessInstanceTTL, arg.HistoryTTLSec, arg.HistoryDeleteSec, arg.Key)
	return err
}
